from prettytable import PrettyTable
import subprocess
import time
import sys
import csv
import os

def check_root_user():
    if os.geteuid() != 0:
        print("This script must be run as root. Exiting.")
        sys.exit(1)

def loading_prompt(message="", art=None):
    if art:
        print(art)
    print(message)
    for _ in range(3):  # Simple loading animation
        print(".", end="", flush=True)
        time.sleep(1)
    print("\n")

# Start up ASCII Art
ascii_art = """
   ___  
  /   \\\\
 /     \\\\
/_______\\\\
\_______/
"""

# MENU OPTIONS
def menu_option_1():
    def ensure_data_directory_exists():
        directory = "/mnt/data"
        if not os.path.exists(directory):
            os.makedirs(directory)
        return directory

    def is_monitor_mode_enabled(interface):
        try:
            result = subprocess.run(['iwconfig', interface], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True)
            output = result.stdout
            return "Mode:Monitor" in output
        except Exception as e:
            print(f"An error occurred while checking monitoring mode: {e}")
            return False

    def enable_monitor_mode(interface):
        try:
            print(f"Enabling monitoring mode on {interface}...")
            result = subprocess.run(['airmon-ng', 'start', interface], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            if is_monitor_mode_enabled(interface + 'mon'):
                print(f"Monitoring mode enabled on {interface}mon")
                return True
            else:
                print("Failed to enable monitoring mode.")
                return False
        except Exception as e:
            print(f"An error occurred while enabling monitoring mode: {e}")
            return False

    def run_airodump(interface):
        try:
            file_prefix = ensure_data_directory_exists() + "/airodump"
            airodump_process = subprocess.Popen(['airodump-ng', '--write', file_prefix, '--output-format', 'csv', interface],
                                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            print("Airodump-ng is running... Press Ctrl+C to stop.")
            try:
                # Let airodump-ng run until user stops it
                airodump_process.wait()
            except KeyboardInterrupt:
                # Terminate airodump-ng when user interrupts the script
                airodump_process.terminate()
                print("\nAirodump-ng stopped by user.")

            # Wait for the process to finish
            airodump_process.communicate()

            # Find the CSV file that was generated by airodump-ng
            directory = ensure_data_directory_exists()
            for file in os.listdir(directory):
                if file.startswith("airodump") and file.endswith('.csv'):
                    csv_file = directory + '/' + file
                    break
            else:
                print("No CSV file generated by airodump-ng.")
                return

            # Extract BSSID, ENC, and SSID into separate files for each access point
            with open(csv_file, mode='r') as file:
                # Skip the first few rows which might have headers or unrelated data
                csv_reader = csv.reader(file)
                for row in csv_reader:
                    if len(row) >= 14:  # Check if row has enough columns
                        bssid = row[0].strip()
                        enc = row[5].strip()
                        ssid = row[13].strip()
                        if bssid and enc and ssid:  # Check for non-empty values
                            filename = directory + '/' + ssid.replace(' ', '_') + '.txt'
                            with open(filename, 'w') as f:
                                f.write(f"BSSID: {bssid}\nENC: {enc}\nSSID: {ssid}\n")
            print("Extraction complete, files saved to", directory)
        except Exception as e:
            print(f"An error occurred: {e}")

    def ask_for_scan(interface):
        response = input("Would you like to perform a scan with airodump-ng? (yes/no): ")
        if response.lower() == 'yes':
            run_airodump(interface)
        else:
            print("Exiting without scanning.")

    interface = 'wlan0'
    mon_interface = 'wlan0mon'

    # Check if wlan0mon is already in monitoring mode
    if is_monitor_mode_enabled(mon_interface):
        print(f"Monitoring mode is already enabled on: {mon_interface}")
        ask_for_scan(mon_interface)
    else:
        print("No network adapter is in monitoring mode.")
        user_input = input("Would you like to enable monitoring mode on wlan0? (yes/no): ")
        if user_input.lower() == 'yes':
            if enable_monitor_mode(interface):
                ask_for_scan(mon_interface)
        else:
            print("Exiting without enabling monitoring mode or scanning.")    

def menu_option_2():
    data_directory = "/mnt/data"
    access_point_files = [f for f in os.listdir(data_directory) if os.path.isfile(os.path.join(data_directory, f)) and f.endswith('.txt')]
    
    if not access_point_files:
        print("No access point files found. Make sure to run a scan first.")
        return
    
    # Create a table with headers
    table = PrettyTable()
    table.field_names = ["SSID", "ENC", "BSSID"]
    
    # Populate the table with data from files
    for file_name in access_point_files:
        file_path = os.path.join(data_directory, file_name)
        with open(file_path, 'r') as file:
            lines = file.readlines()
            ssid = lines[2].split(": ")[1].strip()
            enc = lines[1].split(": ")[1].strip()
            bssid = lines[0].split(": ")[1].strip()
            table.add_row([ssid, enc, bssid])
    
    print("\n")
    print(table)

def menu_option_3():
    print("Crack WEP Access Points")
# More functions can be added here as needed.

# PIVOT MENU OPTIONS
def submenu_option_1():
    passwords_file = "/mnt/data/passwords.txt"
    
    # Check if the passwords file exists
    if not os.path.exists(passwords_file):
        print(f"The file {passwords_file} does not exist.")
        return

    # Initialize a PrettyTable with headers
    table = PrettyTable()
    table.field_names = ["Index", "SSID", "Password"]
    
    try:
        with open(passwords_file, 'r') as file:
            ssid_password_pairs = [line.strip().split(',') for line in file if line.strip()]
        
        # Add each SSID and password pair to the table with an index
        for index, (ssid, password) in enumerate(ssid_password_pairs, start=1):
            table.add_row([index, ssid, password])

        print(table)
    
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")

def submenu_option_2():
    passwords_file = "/mnt/data/passwords.txt"
    ssid_password_pairs = []

    # Read the SSID, Password combinations from the file
    try:
        with open(passwords_file, 'r') as file:
            for line in file:
                parts = line.strip().split(',')
                if len(parts) == 2:
                    ssid_password_pairs.append((parts[0], parts[1]))
    except FileNotFoundError:
        print(f"The file {passwords_file} was not found.")
        return

    # Display the list of SSIDs to the user
    print("Available networks:")
    for i, (ssid, _) in enumerate(ssid_password_pairs, start=1):
        print(f"{i}. {ssid}")

    # Let the user choose an SSID
    choice = input("Enter the number of the Wi-Fi network you want to connect to: ")
    try:
        choice = int(choice) - 1
        if choice < 0 or choice >= len(ssid_password_pairs):
            raise ValueError
    except ValueError:
        print("Invalid selection.")
        return

    ssid, password = ssid_password_pairs[choice]

    # Attempt to connect to the selected Wi-Fi network
    try:
        # Disconnect existing Wi-Fi connections to avoid conflicts
        subprocess.run(['nmcli', 'device', 'disconnect', 'wlan0'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        print(f"Attempting to connect to Wi-Fi SSID: {ssid}")
        connection_result = subprocess.run(['nmcli', 'device', 'wifi', 'connect', ssid, 'password', password], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        if connection_result.returncode == 0:
            print(f"Successfully connected to {ssid}")
        else:
            print(f"Failed to connect to {ssid}: {connection_result.stderr}")

    except subprocess.CalledProcessError as e:
        print(f"An error occurred while trying to connect to the Wi-Fi: {e}")
    
def submenu_option_3():
    print("Enumerate LAN")
# More functions can be added here as needed.

# NAVIGATION
def menu_to_submenu():
    print("Entering Main menu...")
    display_submenu()

def exit_menu():
    print("Exiting menu...")

def display_menu():
    # Define menu options here. Add new options by appending to this list.
    menu_options = [
        {"label": "Access Point Enumeration", "function": menu_option_1},
        {"label": "List Discovered Access Points", "function": menu_option_2},
        {"label": "Crack WEP", "function": menu_option_3},
        {"label": "Pivot", "function": menu_to_submenu},
        # Add new options in this format.
        {"label": "Exit", "function": exit_menu},
    ]
    
    while True:
        print("\nMenu:")
        for i, option in enumerate(menu_options, start=1):
            print(f"{i}. {option['label']}")
        
        try:
            choice = int(input("Select an option: "))
            if 1 <= choice <= len(menu_options):
                menu_options[choice - 1]["function"]()
                if menu_options[choice - 1]["label"] == "Exit":
                    break
            else:
                print("Invalid option, please try again.")
        except ValueError:
            print("Please enter a number.")
        except KeyboardInterrupt:
            print("\nExiting due to Ctrl+C")
            break

def display_submenu():
    submenu_options = [
        {"label": "List Cracked Passwords", "function": submenu_option_1},
        {"label": "Pivot To Access Point", "function": submenu_option_2},
        {"label": "Enumerate LAN", "function": submenu_option_3},
        {"label": "Exit Pivot Menu", "function": exit_menu},
    ]
    
    while True:
        print("\nPivot:")
        for i, option in enumerate(submenu_options, start=1):
            print(f"{i}. {option['label']}")
        
        choice = int(input("Select an option: "))
        if 1 <= choice <= len(submenu_options):
            submenu_options[choice - 1]["function"]()
            if submenu_options[choice - 1]["label"] == "Exit Pivot Menu":
                break
        else:
            print("Invalid option, please try again.")

# Check if the user is root before proceeding
check_root_user()

# Initiate loading menu
loading_prompt("Initializing menu", ascii_art)
display_menu()
